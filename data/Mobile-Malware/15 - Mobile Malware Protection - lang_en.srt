1
00:00:00,320 --> 00:00:03,740
Let's discuss a few approaches
to mobile malware detection.

2
00:00:03,740 --> 00:00:07,060
Please check the instructors notes for
links to these papers.

3
00:00:07,060 --> 00:00:09,310
Kirin is a very simple
system that looks for

4
00:00:09,310 --> 00:00:12,155
suspicious combination of permissions.

5
00:00:12,155 --> 00:00:17,602
RiskRanker use heuristics such as
cryptos that relates to unpacking code.

6
00:00:17,602 --> 00:00:20,620
Similarly, DroidRanger
use heuristics such as

7
00:00:20,620 --> 00:00:23,530
loading native code from
suspicious websites.

8
00:00:23,530 --> 00:00:28,380
DREBEN uses a machine learning algorithm
called SVM, or Support Vector Machine.

9
00:00:28,380 --> 00:00:29,820
And the data attributes used for

10
00:00:29,820 --> 00:00:33,720
modeling include permissions,
API calls, and so on.

11
00:00:33,720 --> 00:00:37,960
Many malicious apps are actually
repackaged version of legitimate apps.

12
00:00:37,960 --> 00:00:41,540
This is actually the most effective
way to distribute malware,

13
00:00:41,540 --> 00:00:45,770
because a popular or cool app
already has a large number of users.

14
00:00:45,770 --> 00:00:48,570
There are research systems
on clone detection.

15
00:00:48,570 --> 00:00:50,440
Here are a few examples.

16
00:00:50,440 --> 00:00:54,590
For example, DroidMOSS use fuzzy
hashing of Java methods to match and

17
00:00:54,590 --> 00:00:56,090
detect clone code.

18
00:00:56,090 --> 00:01:00,050
DNADroid performs similarity
analysis on PDGs.

19
00:01:00,050 --> 00:01:03,580
PDGs are program dependency
graphs between methods.

20
00:01:03,580 --> 00:01:06,590
There are a few sandboxes for
mobile malware analysis.

21
00:01:06,590 --> 00:01:09,600
And these sandboxes
enable dynamic analysis.

22
00:01:09,600 --> 00:01:12,070
Here are a few example sandboxes.

23
00:01:12,070 --> 00:01:16,440
Many dynamic analysis and detection
tools use system call information.

24
00:01:16,440 --> 00:01:18,140
Here are a few examples.

25
00:01:18,140 --> 00:01:22,700
For example, PREC stands for
particle root explore containment.

26
00:01:22,700 --> 00:01:27,031
It can dynamically identify system calls
from high risk components, for example,

27
00:01:27,031 --> 00:01:28,685
third party native libraries.

28
00:01:28,685 --> 00:01:31,970
And execute those system calls
within isolated threads.

29
00:01:31,970 --> 00:01:36,162
Therefore, PREC can detect and
stop root exploits with high accuracy,

30
00:01:36,162 --> 00:01:39,880
while imposing very low interference
to benign applications.

