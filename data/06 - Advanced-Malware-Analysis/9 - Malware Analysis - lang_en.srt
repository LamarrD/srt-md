1
00:00:00,310 --> 00:00:02,910
Now let's discuss malware analysis.

2
00:00:02,910 --> 00:00:05,220
What are the benefits
of malware analysis?

3
00:00:05,220 --> 00:00:07,720
If we understand malware's
network behaviors,

4
00:00:07,720 --> 00:00:11,480
we can create rules to detect and
block malware traffic.

5
00:00:11,480 --> 00:00:14,070
If we understand malware's
on-host behaviors,

6
00:00:14,070 --> 00:00:16,329
we can repair the compromised hosts.

7
00:00:16,329 --> 00:00:20,030
If we have knowledge of the malware's
support infrastructure on the internet

8
00:00:20,030 --> 00:00:24,610
and it's evolution history, we can also
analyze it's trend and threat scope.

9
00:00:24,610 --> 00:00:29,900
Such as, how widespread the malware
is and the likely next target, etc.

10
00:00:29,900 --> 00:00:33,570
Of course, the attackers try to
defeat malware analysis, and

11
00:00:33,570 --> 00:00:37,070
are using the most sophisticated
techniques available.

12
00:00:37,070 --> 00:00:42,110
Another challenge in malware analysis is
the volume of malware is really huge.

13
00:00:42,110 --> 00:00:42,790
Available and

14
00:00:42,790 --> 00:00:48,550
automated tools made a job of creating
malware obfuscated of course very easy.

15
00:00:48,550 --> 00:00:52,180
And in fact there are hundreds of
thousands of new samples every day.

16
00:00:52,180 --> 00:00:56,730
Since the malware creation process is
already automated it is imperative that

17
00:00:56,730 --> 00:01:01,210
malware analysis has to be automated
as well In addition to automation,

18
00:01:01,210 --> 00:01:04,319
malware analysis also
needs to be transparent so

19
00:01:04,319 --> 00:01:07,360
that the malware does not
know it is being analyzed.

20
00:01:07,360 --> 00:01:10,340
Otherwise the malware may refuse to run,
or

21
00:01:10,340 --> 00:01:13,780
purposely alter to its
behaviors to fool the analysis.

22
00:01:13,780 --> 00:01:17,330
This is the so-called malware
uncertainty principle, but

23
00:01:17,330 --> 00:01:18,880
this is very challenging.

24
00:01:18,880 --> 00:01:23,020
In physics, the Heisenberg
principle says that an observer

25
00:01:23,020 --> 00:01:26,610
will inevitably affect
the observed environment.

26
00:01:26,610 --> 00:01:29,460
In malware analysis, our tools may be so

27
00:01:29,460 --> 00:01:33,550
invasive that the malware can
detect them if we're not careful.

28
00:01:33,550 --> 00:01:37,650
In malware analysis, our tools and
techniques are often invasive.

29
00:01:37,650 --> 00:01:39,370
And if we are not careful,

30
00:01:39,370 --> 00:01:43,620
the malware can detect a presence
of the analyzer and refuse to run.

31
00:01:43,620 --> 00:01:47,660
In fact, malware authors already
tried to actively detect

32
00:01:47,660 --> 00:01:49,410
malware analysis tools.

33
00:01:49,410 --> 00:01:52,370
In the malware creation tool kits,
there are standard point and

34
00:01:52,370 --> 00:01:57,410
click options to add logics to detect
various malware analysis methods,

35
00:01:57,410 --> 00:01:59,200
such as these examples.

36
00:01:59,200 --> 00:02:02,260
So we need malware analysis
to be transparent to malware.

37
00:02:02,260 --> 00:02:06,020
That is, malware should not be able
to detect that it is being analyzed.

38
00:02:06,020 --> 00:02:09,400
But how do we fulfill such
transparency requirements?

39
00:02:09,400 --> 00:02:13,830
A malware analyzer should be at a higher
privilege level than a malware, so

40
00:02:13,830 --> 00:02:18,640
that the malware can not directly
access, or know about, the analyzer.

41
00:02:18,640 --> 00:02:19,710
In addition,

42
00:02:19,710 --> 00:02:24,080
the malware may use operations to try
to find the presence of the analyzer.

43
00:02:24,080 --> 00:02:27,790
For example, it may try to find
a side effect of analysis.

44
00:02:27,790 --> 00:02:30,050
These operations should be privileged,
so

45
00:02:30,050 --> 00:02:32,730
that the malware cannot
directly get the answers back.

46
00:02:32,730 --> 00:02:35,760
And, since the analyzer is
at a higher privilege level,

47
00:02:35,760 --> 00:02:38,520
it can actually lie the answers
back to the malware.

48
00:02:38,520 --> 00:02:41,290
That is,
the malware gets the wrong answer and

49
00:02:41,290 --> 00:02:43,400
doesn't know about the side effects.

50
00:02:43,400 --> 00:02:46,630
And obviously, the malware should
get the same correct result

51
00:02:46,630 --> 00:02:50,390
of instruction execution as if
the analyzer is not present.

52
00:02:50,390 --> 00:02:53,640
Likewise, the malware should
see identical signals and

53
00:02:53,640 --> 00:02:56,790
instruction handlings,
as well as time durations.

54
00:02:56,790 --> 00:02:59,700
In terms of fulfilling
the transparency requirements

55
00:02:59,700 --> 00:03:02,120
most interesting tools fall short.

56
00:03:02,120 --> 00:03:05,990
For example, even analyzer
is in guest this means that

57
00:03:05,990 --> 00:03:10,180
the analyzer runs on a same machine and
has the same privilege as the malware

58
00:03:10,180 --> 00:03:12,680
then the analyzer does
not have high privilege.

59
00:03:12,680 --> 00:03:15,340
Some of the analysis study
facts can be discovered but

60
00:03:15,340 --> 00:03:18,130
a malware without privilege operations.

61
00:03:18,130 --> 00:03:21,530
And the exceptions trapped by
the analyzer may be discovered

62
00:03:21,530 --> 00:03:22,570
by the malware.

63
00:03:22,570 --> 00:03:25,310
If the analyzer runs
in a virtual machine

64
00:03:25,310 --> 00:03:29,060
that's based on software
virtualization such as VMWare

65
00:03:29,060 --> 00:03:32,497
then there could be side
effects that can be discovered.

66
00:03:32,497 --> 00:03:35,188
But a malware without
privileged operations.

67
00:03:35,188 --> 00:03:39,590
If the analyzer runs in emulation
environment such as QEMU

68
00:03:39,590 --> 00:03:44,320
the execution semantics of instructions
maybe different from real hardware.

69
00:03:44,320 --> 00:03:48,720
Emulation based malware analysis
tools are the most widely used.

70
00:03:48,720 --> 00:03:50,640
But they have major shortcomings.

71
00:03:50,640 --> 00:03:53,570
The main issue here is that
this emulation emirames

72
00:03:53,570 --> 00:03:56,110
do not fully emulate the hardware.

73
00:03:56,110 --> 00:03:59,620
There is that a corner cases
where a set of instructions

74
00:03:59,620 --> 00:04:03,800
give different results on emulation
emirames versus hardware.

75
00:04:03,800 --> 00:04:06,690
And there have been attacks
based on these corner cases

76
00:04:06,690 --> 00:04:08,850
to detect emulation emirames.

77
00:04:08,850 --> 00:04:11,820
But the bigger problem is that
there is no way to eliminate

78
00:04:11,820 --> 00:04:13,410
all these corner cases.

79
00:04:13,410 --> 00:04:18,170
In fact, in theory there's no way to
guarantee the absence of such attacks.

80
00:04:18,170 --> 00:04:22,060
And the reason is the so-called
EQTM is not decidable.

81
00:04:22,060 --> 00:04:24,600
Which means that when
you view an emulator,

82
00:04:24,600 --> 00:04:29,420
you cannot determine that it behaves
exactly the same as the real machine.

83
00:04:29,420 --> 00:04:32,780
In other words,
you cannot rule out the possibility that

84
00:04:32,780 --> 00:04:37,890
there are situations that your emulator
and the real machine behave differently.

85
00:04:37,890 --> 00:04:41,830
Here's a simple example of
the discrepancies between emulator and

86
00:04:41,830 --> 00:04:43,030
real hardware.

87
00:04:43,030 --> 00:04:47,620
That is, the real hardware will give
an illegal instruction exception, but

88
00:04:47,620 --> 00:04:50,280
an emulator will happily
execute the instruction.

