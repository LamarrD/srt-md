1
00:00:00,270 --> 00:00:04,930
A recent trend is that malware authors
are starting to use emulation-based

2
00:00:04,930 --> 00:00:06,350
obfuscation techniques.

3
00:00:06,350 --> 00:00:09,000
And this is an insertion level approach.

4
00:00:09,000 --> 00:00:12,370
And there are several commercial tools
out there and they can be used for

5
00:00:12,370 --> 00:00:16,030
instrument purposes such as
digital rights management.

6
00:00:16,030 --> 00:00:18,960
So how does emulator-based
obfuscation work?

7
00:00:18,960 --> 00:00:21,270
Suppose we have the original malware and

8
00:00:21,270 --> 00:00:24,130
it is for
x86 instruction set architecture.

9
00:00:24,130 --> 00:00:26,360
For example, your Intel based machines.

10
00:00:26,360 --> 00:00:30,620
The malware is then transformed
into Bytecode Program

11
00:00:30,620 --> 00:00:32,930
of an arbitrary language L.

12
00:00:32,930 --> 00:00:38,760
And then, this emulator, based on L,
will emulate this microprogram on x86.

13
00:00:38,760 --> 00:00:42,260
That is the obfuscated malware

14
00:00:42,260 --> 00:00:46,280
Include both the Bytecode Program and
its emulator.

15
00:00:46,280 --> 00:00:48,850
And when the obfuscated
malware runs on x86,

16
00:00:48,850 --> 00:00:55,370
the emulator will emulate this Bytecode
Program and execute the malware logic.

17
00:00:55,370 --> 00:01:00,490
So what are the impact of emulation
based obfuscation on malware analysis?

18
00:01:00,490 --> 00:01:01,470
First of all,

19
00:01:01,470 --> 00:01:06,790
the malware program now is a Bytecode of
arbitrary language L which is not known.

20
00:01:06,790 --> 00:01:10,200
In fact, the language L can
be randomly generated and

21
00:01:10,200 --> 00:01:13,450
since we don't know the language
L we can not perform

22
00:01:13,450 --> 00:01:17,560
pure static analysis on malware
Bytecode program written in L.

23
00:01:17,560 --> 00:01:19,990
We can perform analysis on the Emulator.

24
00:01:19,990 --> 00:01:24,650
The Emulator actually is not specific
to the malware Bytecode program.

25
00:01:24,650 --> 00:01:27,100
It is only specific to the language L.

26
00:01:27,100 --> 00:01:31,820
In face, the malware Bytecode program
is only one of the possible inputs

27
00:01:31,820 --> 00:01:32,880
to the Emulator.

28
00:01:32,880 --> 00:01:37,440
We can perform dynamic analysis
including some of the low code analysis.

29
00:01:37,440 --> 00:01:39,440
We call this greybox methods.

30
00:01:39,440 --> 00:01:42,430
But such analysis is actually
performed on the Emulator,

31
00:01:42,430 --> 00:01:44,330
not the malware code directly.

32
00:01:44,330 --> 00:01:47,770
The reason is that
the executable is the Emulator.

33
00:01:47,770 --> 00:01:50,370
The malware Bytecode is the input.

34
00:01:50,370 --> 00:01:54,550
Therefore, the analysis results
that we get are from the Emulator,

35
00:01:54,550 --> 00:01:56,860
not directly from the malware Bytecode.

36
00:01:56,860 --> 00:02:00,120
Manual reverse-engineering cannot scale,
because

37
00:02:00,120 --> 00:02:03,940
each instance can have a different
language L, and a different Emulator.

38
00:02:03,940 --> 00:02:08,130
Since the process of creating such
confiscated malware is automated.

39
00:02:08,130 --> 00:02:12,960
We also needed an automated approach
to reverse engineer these Emulators.

40
00:02:12,960 --> 00:02:17,120
By this, we mean that we should not
require knowledge of the language L.

41
00:02:17,120 --> 00:02:19,830
And our approach should be
general enough that will work

42
00:02:19,830 --> 00:02:21,940
on a large class of Emulators.

43
00:02:21,940 --> 00:02:24,820
But is an automated approach possible?

44
00:02:24,820 --> 00:02:26,830
In theory, it is not.

45
00:02:26,830 --> 00:02:31,110
On the other hand, most of the Emulators
have a fetch-decode-execute behavior

46
00:02:31,110 --> 00:02:33,360
that can be identified at runtime and

47
00:02:33,360 --> 00:02:35,880
then can be the starting point
of our reverse engineering.

